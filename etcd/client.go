package tsetcd

import (
	context "context"
	"log"
	"time"

	"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
	clientv3 "go.etcd.io/etcd/clientv3"
)

//EtcdClient is client structure
type EtcdClient struct {
	//worker id which hash been generated by config
	ID string

	//woker infomation
	WorkerInfo string

	Conf clientv3.Config

	IntervalUpdateConf time.Duration

	RequestTimeOut time.Duration
	Done           bool
}

//Put send value to etcd
func (ec *EtcdClient) Put(k, v string) error {

	const timeout = 5

	cli, err := clientv3.New(ec.Conf)
	if err != nil {
		log.Fatalf("Error: connect to registry failed: %v\n", err.Error())
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), ec.RequestTimeOut)
	resp, err := cli.Put(ctx, k, v)

	cancel()

	if err != nil {
		switch err {
		case context.Canceled:
			log.Fatalf("ctx is canceled by another routine: %v", err)
		case context.DeadlineExceeded:
			log.Fatalf("ctx is attached with a deadline is exceeded: %v", err)
		case rpctypes.ErrEmptyKey:
			log.Fatalf("client-side error: %v", err)
		default:
			log.Fatalf("bad cluster endpoints, which are not etcd servers: %v", err)
		}
	} else {
		log.Printf("registry response: %v\n", resp)
	}

	defer cli.Close()
	return nil
}

//IntervalUpdateConfig send all configurations to registry
func (ec *EtcdClient) IntervalUpdateConfig(k, v string) {
	ticker := time.NewTicker(ec.IntervalUpdateConf)
	go func() {
		for ec.Done == false {
			select {
			case <-ticker.C:
				ec.Put(k, v)
			}
		}
		ticker.Stop()
	}()
}

//Get get value from etcd
func (ec *EtcdClient) Get(k string) ([]byte, error) {
	const timeout = 5

	cli, err := clientv3.New(ec.Conf)
	if err != nil {
		log.Fatalf("Error: connect to registry failed: %v\n", err.Error())
		return nil, err
	}

	ctx, cancel := context.WithTimeout(context.Background(), ec.RequestTimeOut)
	resp, err := cli.Get(ctx, k)

	cancel()

	if err != nil {
		switch err {
		case context.Canceled:
			log.Fatalf("ctx is canceled by another routine: %v", err)
		case context.DeadlineExceeded:
			log.Fatalf("ctx is attached with a deadline is exceeded: %v", err)
		case rpctypes.ErrEmptyKey:
			log.Fatalf("client-side error: %v", err)
		default:
			log.Fatalf("bad cluster endpoints, which are not etcd servers: %v", err)
		}
	} else {
		log.Printf("registry response: %v\n", resp)
	}

	defer cli.Close()
	return resp.Kvs[0].Value, nil
}

//GetRange get value from etcd
func (ec *EtcdClient) GetRange(key string) (map[string][]byte, error) {
	const timeout = 5

	cli, err := clientv3.New(ec.Conf)
	if err != nil {
		log.Fatalf("Error: connect to registry failed: %v\n", err.Error())
		return nil, err
	}

	ctx, cancel := context.WithTimeout(context.Background(), ec.RequestTimeOut)
	resp, err := cli.Get(ctx, key, clientv3.WithPrefix())

	cancel()

	if err != nil {
		switch err {
		case context.Canceled:
			log.Fatalf("ctx is canceled by another routine: %v", err)
		case context.DeadlineExceeded:
			log.Fatalf("ctx is attached with a deadline is exceeded: %v", err)
		case rpctypes.ErrEmptyKey:
			log.Fatalf("client-side error: %v", err)
		default:
			log.Fatalf("bad cluster endpoints, which are not etcd servers: %v", err)
		}
	} else {
		log.Printf("registry response: %v\n", resp)
	}

	defer cli.Close()

	kvs := make(map[string][]byte)

	for i := 0; i < len(resp.Kvs); i++ {
		log.Println("key: ", string(resp.Kvs[i].Key), " value: ", string(resp.Kvs[i].Value))
		kvs[string(resp.Kvs[i].Key)] = resp.Kvs[i].Value
	}

	return kvs, nil
}
